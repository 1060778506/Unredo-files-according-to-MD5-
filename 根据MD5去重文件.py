import os
import json
import re
import shutil
import hashlib
import random
import string


#改这里
主路径 = 'Z:/原版沙雕动画/沙雕动画/E音频'

def MD5读取写入TXT(路径):
    Thumbs缩略图数量 = 0
    # 写之前，先检验文件是否存在，存在就删掉
    if os.path.exists("MD5路径.txt"):
        os.remove("MD5路径.txt")
    # 新建txt
    txt = open("MD5路径.txt", 'w', encoding='utf-8')
    # 循环读取文件
    for 当前路径不包含文件名, 仅子文件夹名, 仅完整文件名带后缀 in os.walk(路径):
        for 单文件名带后缀 in 仅完整文件名带后缀:
            if str(单文件名带后缀) == "Thumbs.db":
                Thumbs缩略图数量 = Thumbs缩略图数量 + 1
                pass
            else:
                # 自动成为路径,自动补充反斜杠
                完整旧文件路径带后缀 = os.path.join(当前路径不包含文件名, 单文件名带后缀).replace('/', '\\')
                # -------开始处理BUG------
                #删除掉不可见字符
                最终字符串全部名字=''
                for 单个 in 单文件名带后缀:
                    if 单个.isprintable():
                        最终字符串全部名字+=单个
                    else:#空值pass,
                        pass
                #删除之后,如果相等,则没有BUG零宽度字符
                if len(单文件名带后缀) == len(最终字符串全部名字):
                    pass
                else:
                    #拼接路径,删除空值的路径
                    完整文件路径带后缀 = os.path.join(当前路径不包含文件名, 最终字符串全部名字).replace('/', '\\')
                    #是否有这个文件
                    #移动之前,先看一下文件夹是否存在,如果不存在则创建
                    if not os.path.exists(完整文件路径带后缀):
                        #可以改名字了,因为不存在直接改名字
                        shutil.move(完整旧文件路径带后缀,完整文件路径带后缀)
                    else:
                        #如果存在，那麻烦了，需要改一个不重名的文件
                        #生成一个变量生成密码
                        password = ''.join(random.choice(string.ascii_letters + string.digits + string.digits) for i in range(16))
                        #拆分路径和带后缀文件名
                        file_path, file_name = os.path.split(完整文件路径带后缀)
                        #纯文件名和后缀
                        short_name, 后缀 = os.path.splitext(file_name)
                        #删掉一半名字,防止BUG
                        新最终字符串全部名字 = short_name[:len(short_name)//2]
                        #改后的文件名,
                        完整文件路径带后缀 = str(f'{file_path}/{新最终字符串全部名字}{"重名空字符"}{password}{"重名空字符"}{后缀}').replace('/', '\\')
                        shutil.move(完整旧文件路径带后缀,完整文件路径带后缀)

                    #改完名字需要在此获取一遍,直接赋予
                    完整旧文件路径带后缀 = 完整文件路径带后缀
                # -------结束处理BUG------
                # --------
                # 开始进行MD5计算,读取二进制,
                with open(完整旧文件路径带后缀, 'rb') as f:
                    # 二进制结果保存到file_data
                    file_data = f.read()
                # 创建一个对象,用来计算MD5
                md5_obj = hashlib.md5()
                # 读到的内容给md5_obj对象,更新MD5值
                md5_obj.update(file_data)
                # 获取文件的MD5值
                md5 = md5_obj.hexdigest()
                # --------
                # 写入路径
                txt.write(完整旧文件路径带后缀+'\n')
                # 写入MD5
                txt.write(md5+'\n')
    # 关闭txt
    txt.close()
    # 改名字
    shutil.move('MD5路径.txt','MD5路径-缩略图_'+str(Thumbs缩略图数量)+'.txt')
    return Thumbs缩略图数量

Thumbs缩略图数量 = MD5读取写入TXT(主路径)


def 读取文件到内存字典():
    #提取数据并且分类
    合集路径=[]
    完整的合集MD5=[]
    i = 0

    # 获取符合规则的所有文件名
    符合名的文件 = []
    for f in os.listdir('.'):
       #循环
        if re.match(r'MD5路径-缩略图_\d+\.txt', f):
            符合名的文件.append(f)
    if len(符合名的文件) != 1:
        print(len(符合名的文件))
        input("不可能不等于1,不可能是两个文件夹")
    #结束获取所有文件
    with open(符合名的文件[0],'r',encoding='utf-8') as f:
        for line in f:
            if 0 == i:
                i = i+1
                #等于0就是路径,根据换行符来切割
                合集路径.append(line.strip('\n'))
            else:
                i = i-1
                #不是0就是MD5,根据换行符来切割
                完整的合集MD5.append(line.strip('\n'))

    #查看路径是否会重复,如果重复100%出现BUG
    if len(合集路径) == len(set(合集路径)):
        #不重复
        pass
    else:
        print(len(合集路径))
        print(len(set(合集路径)))
        input("文件夹内出现重复路径,这是不可能的事情")

    #查看路径是否会重复,如果重复100%出现BUG
    #分类处理后加入字典,必须跑完所有文件名字,后进行统一处理
    未处理名字字典 = {}
    # 循环所有的MD5,如果唯一则记录位置,如果重复路径则追加到字典值
    i=0
    for 单个MD5 in 完整的合集MD5:
        单个MD5 = str(单个MD5)
        单个路径 = str(合集路径[i])
        # 获取文件所在目录 文件所在路径: C:/Users/Administrator/Desktop
        文件所在目录 = os.path.dirname(单个路径)
        # 获取文件名和后缀 文件名: example  后缀: .txt
        纯文件名, 纯后缀 = os.path.splitext(os.path.basename(单个路径))
        if 单个MD5 not in 未处理名字字典:
            未处理名字字典[单个MD5] = {"名字": [纯文件名], "旧完整路径": 单个路径, "所在路径": 文件所在目录, "纯后缀": 纯后缀}
        else:#更新
            未处理名字字典[单个MD5]["名字"].append(纯文件名)
        i=i+1

    #一定要本身去重,得到唯一的MD5在循环
    唯一合集MD5 = list(set(完整的合集MD5))
    #全部跑完,返回字典
    return 未处理名字字典,唯一合集MD5,合集路径,完整的合集MD5

def 处理列表名字(未处理的名字,单个MD5):
    #收到了[名字,名字,名字]
    处理后的名字单个列表 = []
    #print(未处理的名字)
    #i=1
    for 单个未处理名字 in 未处理的名字:
        #替换法替换掉违禁词
        违禁词 = [' ','淘宝', '副本', '素材', '旺旺hy6575365', 'qq截图', '微信', '公众号', '录制', '海豚资源库', '麦兜之歌', '资源V：xz38006', '.', '-', '手机电脑通用', 'QQ图片', '闲猪旗舰店']
        名称 = 单个未处理名字
        for 单违禁词 in 违禁词:
            名称 = 名称.replace(单违禁词, '')
            #正则替换掉不规律违禁词,
            名称 = re.sub(r'(\([0-9]+\))', '', 名称)
            名称 = re.sub(r'(（[0-9]+）)', '', 名称)
            名称 = re.sub(r'(（[0-9]+\))', '', 名称)
            名称 = re.sub(r'(\([0-9]+）)', '', 名称)
            名称 = re.sub(r'([a-f\d]{32}|[A-F\d]{32})', '', 名称)
            名称 = re.sub(r'([#￥,，;:：$\'!？……&\*【】\[\]@\(\)（）])', '', 名称)
        #print(名称)
        #处理名字后,判断是否还有数据,如果没有不用添加，或者就是空
        if 名称.isdigit() or 名称 == '-' or 名称.strip()=="":
            pass
        else:#还有有效数据则添加
            处理后的名字单个列表.append(名称)
    #-------以上预处理完成------返回的数据和函数第一次收到的数据格式一样
    
    #如果是空值直接返回吧
    if len(处理后的名字单个列表) == 0:
        字符串全部名字 = "【没有名字自行命名】"
    else:
        # 列表去重后,按降序对列表进行就地排序
        处理后的名字单个列表 = list(set(处理后的名字单个列表))
        处理后的名字单个列表.sort(reverse=True)

        #列表先处理成为字符串
        字符串全部名字 = ''
        for 处理后的名字单个列表在单 in 处理后的名字单个列表:
            字符串全部名字+="【"+str(处理后的名字单个列表在单)+"】"

        #判断是否大于218,MD5占用32字符,总共250
        名字长度 = len(字符串全部名字.encode())
        if 名字长度 > 218 and 名字长度 != 218:
            #名字太长需要处理
            while 名字长度 > 218 and 名字长度 != 218:
                #先看下列表还剩几个字符串,如果剩一个不要删除,2个包括以上则删除
                if len(处理后的名字单个列表) == 1:
                    #如果还不行,这里则,删除英文和数字！！！！！！
                    #就剩一个字符了,不要删除了
                    字符串 = 处理后的名字单个列表[0]
                    for 单个字符串字符 in 字符串:
                        字符串[:-1]#因为【】是6个字符串,所以218必须减6,腾出来两个【】这样的字符,
                        if len(字符串) < 212:
                            break#小于212跳出for
                    处理后的名字单个列表 = [字符串,]
                    break
                else:
                    #如果还不行,这里则,删除英文和数字！！！！！！
                    #不等于1则删除一个字符串,删除最后一个字符串
                    处理后的名字单个列表.pop()
                    #删除之后查看,长度是多少了
                    名字长度 = 0
                    for 单个列表内字符串 in 处理后的名字单个列表:
                        名字长度 += len(单个列表内字符串.encode())+6# 更新总长度,必须加上6,因为【】是占用6个字符,
                    if 名字长度 < 218 and 名字长度 != 218:
                        break
        else:
            pass
        #因为长度太长,又把字符串转为了列表,所以在转换一边,
        #列表先处理成为字符串
        字符串全部名字 = ''
        for 处理后的名字单个列表在单 in 处理后的名字单个列表:
            字符串全部名字+="【"+str(处理后的名字单个列表在单)+"】"

        #这次应该不会大于251,实际是255
        长度 = len(字符串全部名字.encode())
        if 长度 > 251 and 长度 != 251:
            print(单个MD5)
            print(未处理的名字)
            print("文件名字大于251"+str(处理后的名字单个列表在单))
            print(处理后的名字单个列表)
            print(长度)
            input("很神奇")

    #删除掉不可见字符
    最终字符串全部名字=''
    for 单个 in 字符串全部名字:
        if 单个.isprintable():
            最终字符串全部名字+=单个
        else:#空值pass
            pass

    #返回带MD5的字符串,直接回家
    return 最终字符串全部名字+str(单个MD5)




#在字典内处理名字后再写入字典,
(未处理名字字典,唯一合集MD5,合集完整路径,完整的合集MD5) = 读取文件到内存字典()
# 循环所有的MD5,如果唯一则记录位置,如果重复路径则追加到字典值
i=0
for 单个唯一MD5 in 唯一合集MD5:
    #拿到未处理名字
    未处理的名字 = 未处理名字字典[单个唯一MD5]['名字']
    #挨个循环处理,把列表发给函数处理[名字,名字,名字]
    处理后名字单个列表 = 处理列表名字(未处理的名字,单个唯一MD5)
    #print(处理后名字单个列表)
    #更新名字
    未处理名字字典[单个唯一MD5]["名字"]=处理后名字单个列表
    已处理字典 = 未处理名字字典
    #接下来生成完整的路径
    所在路径 = 已处理字典[单个唯一MD5]["所在路径"]
    名字 = 已处理字典[单个唯一MD5]["名字"]
    纯后缀 = 已处理字典[单个唯一MD5]["纯后缀"]
    #追加键值
    已处理字典[单个唯一MD5]["更新后的完整路径"] = os.path.join(所在路径, 名字+纯后缀)
已处理名字字典 = 未处理名字字典



#开始改名字,
k=0
字典 = 已处理名字字典.copy()
for 重复的路径 in 合集完整路径:
    #先读取
    单个路径 = 重复的路径
    单个MD5 = 完整的合集MD5[k]
    #字典内容 = 字典[单个MD5]
    #用MD5去找字典,判断是否存在这个键
    if 单个MD5 in 字典:
        #存在,则改名
            #旧完整路径 = 字典[单个MD5]["旧完整路径"]
        #还是使用规定的文件路径把,如果使用字典内的旧路径,有可能旧文件已经被移动,
        单个路径 = 单个路径
        新完整路径 = 字典[单个MD5]["更新后的完整路径"]
        shutil.move(单个路径,新完整路径)
        #改完名字后删除这个字典键值
        del 字典[单个MD5]
    else:
        #不存在,则移动文件后改名字
        # 分离文件路径和文件名,Z:/沙雕动画,1(1).jpg'
        文件路径, 文件名带后缀 = os.path.split(单个路径)
        # 分离文件名和扩展名 1(1) .jpg'
        纯文件名, 扩展名 = os.path.splitext(文件名带后缀)
        # 在文件路径中加入重复文件标识符Z:/沙雕动画/丰茂德重复文件标识符
        文件路径 = os.path.join(文件路径, '丰茂德重复文件标识符')
        #删除掉不可见字符
        最终字符串全部名字=''
        for 单个 in 纯文件名:
            if 单个.isprintable():
                最终字符串全部名字+=单个
            else:#空值pass
                pass

        #纯文件名不可以大于215
        #这次应该不会大于251,实际是255
        长度 = len(最终字符串全部名字.encode())
        while 长度 > 212 and 长度 != 212:
            #删除字符串最后一个
            最终字符串全部名字 = 最终字符串全部名字[:-1]
            #获取长度
            长度 = len(最终字符串全部名字.encode())

        # 拼接新的文件名 【md5】1(1).jpg
        拼接后的新名字 = f'【{单个MD5}】 {最终字符串全部名字}{扩展名}'
        # 组合新的文件路径 Z:/沙雕动画/丰茂德重复文件标识符/【MD5】1(1).jpg
        真正新名字路径 = os.path.join(文件路径, 拼接后的新名字)
        #移动之前,先看一下文件夹是否存在,如果不存在则创建
        if not os.path.exists(文件路径):
            os.makedirs(文件路径)
        #开始移动
        单个路径 = 单个路径
        try:
            shutil.move(单个路径,真正新名字路径)
            #报错任何异常都认为是重名,
        except BaseException:
            #生成一个变量
            # 生成密码
            password = ''.join(random.choice(string.ascii_letters + string.digits + string.digits) for i in range(16))
            #主要更新的是拼接后的新名字,和最终字符串全部名字
            #如果是0个字符或者1个字符不能一分为二,则直接追加变量
            新最终字符串全部名字=''
            if len(最终字符串全部名字) !=0 and (最终字符串全部名字) !=1:
                新最终字符串全部名字 = 最终字符串全部名字[:len(最终字符串全部名字)//2]
                拼接后的新名字 = f'【{单个MD5}】 {新最终字符串全部名字}{"重名"}{password}{"重名"}{扩展名}'
            else:
                # 拼接新的文件名 【md5】1(1).jpg,就是等于0等于1,则直接追加变量拼接就可以了
                拼接后的新名字 = f'【{单个MD5}】 {最终字符串全部名字}{"重名"}{password}{"重名"}{扩展名}'
            #重新进行组装
            真正新名字路径 = os.path.join(文件路径, 拼接后的新名字)
            shutil.move(单个路径,真正新名字路径)
        
    k=k+1

#验证,字典应该是0
if len(字典) == 0 and len(合集完整路径) == len(完整的合集MD5):
    #是零则pass
    pass
else:
    #这不可能不等于零,没有处理完?
    print("必须是0:"+str(len(字典)))
    print("这两个数必须相等"+str(len(合集完整路径)))
    print("这两个数必须相等"+str(len(完整的合集MD5)))
    input(字典)

#写入到TXT,打开文件，如果不存在则新建一个
with open('合并后字典.txt', 'w',encoding='utf-8') as f:
    # 将字典以JSON格式写入文件,
    json.dump(已处理名字字典,f,ensure_ascii=False,indent=4)
print("字典剩余应该是0"+str(len(字典)))
print("MD5总数量一样的"+str(len(完整的合集MD5)))
print("路径总数量一样的"+str(len(合集完整路径)))
print("字典数量无用应该是唯一的"+str(len(已处理名字字典)))
print("唯一MD5数量"+str(len(唯一合集MD5)))
print("Thumbs缩略图数量"+str(Thumbs缩略图数量))
print("缩略图和路径总数量相加是全部文件数量"+str(Thumbs缩略图数量)+str(len(合集完整路径)))

input("完成")